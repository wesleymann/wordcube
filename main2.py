import os
from collections import defaultdict


def load_word_list(filename='word_list_10000.txt', top_n=None):
    """Load words from `filename` or from a system dictionary if file missing.

    If `filename` is None or 'system', attempt to load the system dictionary
    from common locations on macOS/Linux (e.g. /usr/share/dict/words). If no
    source is found, fall back to `word_list_tiny.txt` or raise.
    """
    tried = []

    def read_file(path):
        with open(path, 'r') as f:
            return [w.strip().lower() for w in f if w.strip()]

    # If caller explicitly asked for system or passed None, prefer system dicts
    if filename in (None, 'system'):
        system_paths = ['/usr/share/dict/words', '/usr/dict/words', '/usr/dict/web2']
        for p in system_paths:
            tried.append(p)
            if os.path.exists(p):
                print(f"Using system dictionary: {p}")
                words = read_file(p)
                break
        else:
            # No system dict found; fall back to default file next
            filename = 'word_list_10000.txt'

    # If we still have a filename, try it, otherwise attempt fallbacks
    if filename and filename not in (None, 'system'):
        tried.append(filename)
        if os.path.exists(filename):
            print(f"Using word list file: {filename}")
            words = read_file(filename)
        else:
            # try tiny fallback
            fallback = 'word_list_tiny.txt'
            tried.append(fallback)
            if os.path.exists(fallback):
                print(f"{filename} not found â€” falling back to {fallback}.")
                words = read_file(fallback)
            else:
                raise FileNotFoundError(f"None of these files exist: {tried}")

    # Filter to 4-letter alphabetical words
    words = [w for w in words if len(w) == 4 and w.isalpha()]
    if top_n:
        words = words[:top_n]
    return words


def build_prefix_map(words):
    pm = defaultdict(list)
    for w in words:
        for i in range(5):  # prefixes of length 0..4
            pm[w[:i]].append(w)
    return pm


def find_word_cubes(words, N=4, max_results=None):
    """Find N x N matrices where each row is a word and each column is a word.

    Uses prefix pruning. Returns list of row-lists. If `max_results` is set,
    stops after that many matrices are found.
    """
    prefix_map = build_prefix_map(words)
    word_set = set(words)
    results = []

    def candidates_for_next(rows):
        k = len(rows)
        if k == 0:
            return words
        needed_prefixes = [''.join(rows[i][j] for i in range(k)) for j in range(N)]

        # Start with intersection of pools of words that begin with each
        # column-prefix (this reduces the search space).
        # Choose the column whose current prefix pool is smallest to iterate
        # fewer candidates.
        pools = [(len(prefix_map.get(pref, [])), idx) for idx, pref in enumerate(needed_prefixes)]
        pools.sort()
        _, best_j = pools[0]
        base_list = prefix_map.get(needed_prefixes[best_j], [])

        good = []
        for w in base_list:
            ok = True
            for j in range(N):
                pref = needed_prefixes[j] + w[j]
                if pref not in prefix_map:
                    ok = False
                    break
            if ok:
                good.append(w)
        return good

    def backtrack(rows, used):
        if max_results and len(results) >= max_results:
            return
        k = len(rows)
        if k == N:
            cols = [''.join(rows[r][c] for r in range(N)) for c in range(N)]
            if all(c in word_set for c in cols) and len(set(rows + cols)) == 2 * N:
                results.append(rows.copy())
            return

        for candidate in candidates_for_next(rows):
            if candidate in used:
                continue
            used.add(candidate)
            rows.append(candidate)
            backtrack(rows, used)
            rows.pop()
            used.remove(candidate)

    for w in words:
        backtrack([w], {w})
        if max_results and len(results) >= max_results:
            break

    return results


def main():
    # Use the word list generated by `get_list` (word_list_wordfreq.txt)
    words = load_word_list(filename='word_list_wordfreq.txt', top_n=10000)
    print(f"Loaded {len(words)} 4-letter words from word_list_wordfreq.txt (top_n=10000).")

    N = 4
    squares = find_word_cubes(words, N=N, max_results=None)

    # Final filter: require rows unique, columns unique, and no row equals any column
    total_before = len(squares)
    valid_squares = []
    discarded = []  # store (reason, square)
    for sq in squares:
        rows = sq
        cols = [''.join(sq[r][c] for r in range(N)) for c in range(N)]
        if len(set(rows)) != N:
            discarded.append(("duplicate_row", sq))
            continue
        if len(set(cols)) != N:
            discarded.append(("duplicate_col", sq))
            continue
        if set(rows).intersection(set(cols)):
            discarded.append(("row_equals_column", sq))
            continue
        valid_squares.append(sq)

    print(f"Found {total_before} candidate squares before filtering.")
    print(f"Accepted {len(valid_squares)} after filtering; discarded {len(discarded)}.\n")

    # Print paired examples: accepted (if any) alongside a discarded example (with reason)
    max_examples = 10
    print("Examples (Accepted | Discarded):")
    for i in range(max_examples):
        acc = valid_squares[i] if i < len(valid_squares) else None
        reason, disc = discarded[i] if i < len(discarded) else (None, None)
        print(f"\nExample {i+1}:")
        if acc:
            print("Accepted:")
            for row in acc:
                print(' '.join(row))
        else:
            print("Accepted: <none>")
        print("---")
        if disc:
            print(f"Discarded ({reason}):")
            for row in disc:
                print(' '.join(row))
        else:
            print("Discarded: <none>")

    if valid_squares:
        print(f"\nShowing first 20 valid squares:")
        for sq in valid_squares[:20]:
            for row in sq:
                print(' '.join(row))
            print()
    else:
        print("\nNo valid word squares found after filtering.")

    # Write all valid squares to a file for later use
    out_file = 'word_cubes.txt'
    with open(out_file, 'w') as f:
        for sq in valid_squares:
            for row in sq:
                f.write(' '.join(row) + '\n')
            f.write('\n')
    print(f"Wrote {len(valid_squares)} word cubes to {out_file}")


if __name__ == '__main__':
    main()
