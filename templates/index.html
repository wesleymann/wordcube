{% extends "base.html" %}
{% block content %}

<!-- Welcome Modal -->
<div id="welcome-modal" class="modal-overlay" style="display: none;">
  <div class="modal">
    <h2>How to Play</h2>
    <p>Fill in the 4x4 grid with words. Some letters are revealed to help you start.</p>
    <p><strong>Feedback colors:</strong></p>
    <p><span class="example-tile correct">G</span> <strong>Green:</strong> Correct letter in the right position</p>
    <p><span class="example-tile present">P</span> <strong>Purple:</strong> Letter exists in the same row or column, but wrong position</p>
    <p><span class="example-tile elsewhere">Y</span> <strong>Yellow:</strong> Letter exists elsewhere on the grid (not in same row/column)</p>
    <p>Good luck!</p>
    <button class="modal-button" tabindex="-1">Start Playing</button>
  </div>
</div>

<!-- Share Modal (manual copy fallback) -->
<div id="share-modal" class="modal-overlay" style="display: none;">
  <div class="modal">
    <h2>Share Result</h2>
    <p>Copy your result below:</p>
    <textarea id="share-text" class="share-text" readonly rows="8"></textarea>
    <button id="share-copy-btn" class="modal-button" tabindex="-1">Copy</button>
    <button id="share-close-btn" class="modal-button" tabindex="-1">Close</button>
  </div>
</div>

<div class="game-meta">
  <button class="help-button" id="help-btn" aria-label="Show help" tabindex="-1">?</button>
  <div class="game-links">
    <a href="{{ url_for('new_game') }}">Play Random Cube</a>
    <span class="sep">|</span>
    <a href="{{ url_for('daily_game') }}">Return to Daily</a>
    <span class="sep">|</span>
    <a href="{{ url_for('reveal_answer') }}">Reveal Answer</a>
  </div>
</div>

<h3 class="board-title">
  {% if game_mode == 'daily' %}
    Daily Cube{% if daily_date_display %} â€¢ {{ daily_date_display }}{% endif %}
  {% else %}
    Custom Game
  {% endif %}
</h3>
{# Compute last attempt/feedback if present #}
{% set last_attempt = attempts[-1] if attempts else None %}
{% set last_feedback = feedbacks[-1] if feedbacks else None %}

<div id="board" class="cube-grid {% if shake %}shake{% endif %}">
  {% for r in range(4) %}
    <div class="cube-row">
      {% for c in range(4) %}
        {% set ch = cube[r][c].upper() %}
        {% if (r, c) in revealed %}
          <div class="board-input revealed" contenteditable="false">{{ ch }}</div>
        {% else %}
          {# If there was a last attempt, use its letter and feedback for this cell #}
          {% if last_attempt and last_feedback %}
            {% set guessed_row = last_attempt[r] %}
            {% set fb_row = last_feedback[r] %}
            {% set letter = guessed_row[c].upper() if guessed_row|length > c else '' %}
            {% set fbchar = fb_row[c] if fb_row|length > c else '_' %}
            {% if fbchar == 'G' %}
              <div class="board-input correct" contenteditable="false" data-fb="G">{{ letter }}</div>
            {% elif fbchar == 'Y' %}
              <div class="board-input present" contenteditable="true" data-fb="Y" inputmode="none" virtualkeyboardpolicy="manual" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">{{ letter }}</div>
            {% elif fbchar == 'P' %}
              <div class="board-input elsewhere" contenteditable="true" data-fb="P" inputmode="none" virtualkeyboardpolicy="manual" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">{{ letter }}</div>
            {% else %}
              {# show the previous guessed letter in black so it's visible on next guess #}
              <div class="board-input absent" contenteditable="true" data-fb="_" inputmode="none" virtualkeyboardpolicy="manual" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">{{ letter }}</div>
            {% endif %}
          {% else %}
            <div class="board-input" contenteditable="true" data-fb="_" inputmode="none" virtualkeyboardpolicy="manual" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></div>
          {% endif %}
        {% endif %}
      {% endfor %}
    </div>
  {% endfor %}
</div>

<div id="solved-banner" style="display: {{ 'block' if solved else 'none' }};">
  <p class="success">Solved! Well done.</p>
  <button id="share-btn" onclick="shareResult()" style="width: 100%; padding: 10px; background: #111827; color: #ffffff; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; margin-top: 12px;">Share Result</button>
</div>

<div class="timer" id="timer" data-start="{{ start_time|default('', true) }}" data-end="{{ end_time|default('', true) }}">
  Time: <span id="timer-value">00:00</span>
</div>

<canvas id="celebration-canvas" aria-hidden="true" style="display: {{ 'block' if solved else 'none' }}; pointer-events: none;"></canvas>

<form id="guess-form" method="post" action="{{ url_for('guess') }}">
  <!-- hidden row fields populated by JS from board inputs -->
  {% for i in range(4) %}
    <input type="hidden" name="row{{ i }}" id="row{{ i }}-hidden">
  {% endfor %}
</form>

<div class="keyboard" aria-label="On-screen keyboard">
  <div class="key-row">
    {% for k in ['Q','W','E','R','T','Y','U','I','O','P'] %}
      <button type="button" class="key" data-key="{{ k }}" tabindex="-1">{{ k }}</button>
    {% endfor %}
  </div>
  <div class="key-row">
    {% for k in ['A','S','D','F','G','H','J','K','L'] %}
      <button type="button" class="key" data-key="{{ k }}" tabindex="-1">{{ k }}</button>
    {% endfor %}
  </div>
  <div class="key-row">
    <button type="button" class="key key-wide" data-key="ENTER" tabindex="-1">Enter</button>
    {% for k in ['Z','X','C','V','B','N','M'] %}
      <button type="button" class="key" data-key="{{ k }}" tabindex="-1">{{ k }}</button>
    {% endfor %}
    <button type="button" class="key key-wide" data-key="DEL" tabindex="-1">Del</button>
  </div>
</div>

<script>
// Use pre-computed keyboard state from server instead of storing all attempts
const keyboard_state = {{ keyboard_state | tojson }};
const cube = {{ cube | tojson }};  // Client-side cube for feedback computation
const gameHistory = {
  attempts: {{ attempts | tojson }},
  feedbacks: {{ feedbacks | tojson }},
  solved: {{ 'true' if solved else 'false' }},
  revealed: new Set({{ (revealed | list) | tojson }}.map(pair => `${pair[0]},${pair[1]}`))
};
window.gameHistory = gameHistory;

/**
 * Client-side feedback computation - mirrors compute_feedback_enhanced from app.py
 * Returns a 4-character string with G/Y/P/_ for each letter in the guess
 */
function computeFeedback(guessRow, solutionRow, rowIdx, allAttempts, allFeedbacks, revealedSet, cubeData, allGreensFromSubmission) {
  const result = ['_', '_', '_', '_'];
  
  // Collect all green positions from previous attempts and current submission
  const allGreens = new Set();
  
  if (allGreensFromSubmission) {
    allGreensFromSubmission.forEach(pos => allGreens.add(pos));
  }
  
  // Add greens from previous feedbacks
  if (allFeedbacks && allFeedbacks.length > 0) {
    allFeedbacks.forEach((fbRows, attemptIdx) => {
      fbRows.forEach((fbRow, rowIdxFb) => {
        fbRow.split('').forEach((fbChar, colIdx) => {
          if (fbChar === 'G') {
            allGreens.add(`${rowIdxFb},${colIdx}`);
          }
        });
      });
    });
  }
  
  // PASS 1: Mark correct positions (green)
  for (let i = 0; i < 4; i++) {
    const ch = guessRow[i] || ' ';
    if (ch === ' ') {
      result[i] = '_';
    } else if (ch === solutionRow[i]) {
      result[i] = 'G';
      allGreens.add(`${rowIdx},${i}`);
    }
  }
  
  // PASS 2: Mark yellow (in same row or column, but not green)
  for (let i = 0; i < 4; i++) {
    const ch = guessRow[i] || ' ';
    if (ch === ' ' || result[i] === 'G') continue;
    
    const revealedKey = `${rowIdx},${i}`;
    if (revealedSet.has(revealedKey)) {
      result[i] = '_';
      continue;
    }
    
    let inRow = false;
    let inCol = false;
    
    // Check same row
    for (let c = 0; c < 4; c++) {
      if (c === i) continue;
      const posKey = `${rowIdx},${c}`;
      if (revealedSet.has(posKey)) continue;
      if (cubeData[rowIdx][c] === ch && !allGreens.has(posKey)) {
        inRow = true;
        break;
      }
    }
    
    // Check same column
    for (let r = 0; r < 4; r++) {
      if (r === rowIdx) continue;
      const posKey = `${r},${i}`;
      if (revealedSet.has(posKey)) continue;
      if (cubeData[r][i] === ch && !allGreens.has(posKey)) {
        inCol = true;
        break;
      }
    }
    
    if (inRow || inCol) {
      result[i] = 'Y';
    }
  }
  
  // PASS 3: Mark purple (exists elsewhere on grid, not in same row/col, not green, not yellow)
  for (let i = 0; i < 4; i++) {
    const ch = guessRow[i] || ' ';
    if (ch === ' ' || result[i] === 'G' || result[i] === 'Y') continue;
    
    const revealedKey = `${rowIdx},${i}`;
    if (revealedSet.has(revealedKey)) {
      result[i] = '_';
      continue;
    }
    
    let foundElsewhere = false;
    outer: for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        if (cubeData[r][c] === ch) {
          const posKey = `${r},${c}`;
          // Skip if revealed, green, or in same row/column
          if (revealedSet.has(posKey) || allGreens.has(posKey)) continue;
          if (r === rowIdx || c === i) continue;
          
          foundElsewhere = true;
          break outer;
        }
      }
    }
    
    result[i] = foundElsewhere ? 'P' : '_';
  }
  
  return result.join('');
}

/**
 * Compute feedback for all 4 rows of a submission
 */
function computeFullFeedback(guessRows, cubeData, revealedSet, allAttempts, allFeedbacks) {
  const allGreensInSubmission = new Set();
  
  // First pass: identify all greens in this submission (row order independent)
  for (let r = 0; r < 4; r++) {
    const guessRow = guessRows[r] || '';
    const solutionRow = cubeData[r];
    for (let c = 0; c < 4; c++) {
      const ch = guessRow[c] || ' ';
      if (ch !== ' ' && ch === solutionRow[c]) {
        allGreensInSubmission.add(`${r},${c}`);
      }
    }
  }
  
  // Second pass: compute feedback for each row with all greens known
  const allFeedback = [];
  for (let r = 0; r < 4; r++) {
    const guessRow = guessRows[r] || '';
    const solutionRow = cubeData[r];
    const fb = computeFeedback(guessRow, solutionRow, r, allAttempts, allFeedbacks, revealedSet, cubeData, allGreensInSubmission);
    allFeedback.push(fb);
  }
  
  return allFeedback;
}



const OfflineQueue = {
  storageKey: 'wordcube-pending-guesses',
  
  /**
   * Add a guess to the queue
   */
  add(guess, feedback) {
    const queue = this.getAll();
    queue.push({
      guess: guess,
      feedback: feedback,
      timestamp: Date.now(),
      synced: false
    });
    localStorage.setItem(this.storageKey, JSON.stringify(queue));
    console.log('ðŸ“ Queued guess to localStorage:', guess, 'Total pending:', queue.length);
  },
  
  /**
   * Get all pending guesses
   */
  getAll() {
    try {
      const data = localStorage.getItem(this.storageKey);
      return data ? JSON.parse(data) : [];
    } catch (e) {
      console.error('âŒ Failed to read queue from localStorage:', e);
      return [];
    }
  },
  
  /**
   * Mark guesses as synced and remove them
   */
  clearSynced() {
    localStorage.removeItem(this.storageKey);
    console.log('âœ… Cleared synced guesses from queue');
  },
  
  /**
   * Get count of pending guesses
   */
  count() {
    return this.getAll().length;
  }
};

/**
 * Sync pending guesses with server
 */
async function syncPendingGuesses() {
  const queue = OfflineQueue.getAll();
  if (queue.length === 0) {
    console.log('ðŸ“Š No pending guesses to sync');
    return true;
  }
  
  console.log(`ðŸ”„ Syncing ${queue.length} pending guesses...`);
  
  try {
    for (const item of queue) {
      const formData = new FormData(document.getElementById('guess-form'));
      // Override with the queued guess rows
      for (let i = 0; i < 4; i++) {
        formData.set(`row${i}`, item.guess[i]);
      }
      
      const response = await fetch('{{ url_for("guess") }}', {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        console.warn(`âš ï¸ Failed to sync guess (HTTP ${response.status}):`, item.guess);
        return false;
      }
    }
    
    OfflineQueue.clearSynced();
    console.log('âœ… All pending guesses synced successfully');
    return true;
  } catch (error) {
    console.error('âŒ Sync failed:', error);
    return false;
  }
}

/**
 * Schedule periodic sync attempts every 5 seconds
 */
function startSyncScheduler() {
  setInterval(async () => {
    if (OfflineQueue.count() > 0) {
      await syncPendingGuesses();
    }
  }, 5000);
  console.log('ðŸ• Sync scheduler started (5s interval)');
}

document.addEventListener('DOMContentLoaded', function(){
  const form = document.getElementById('guess-form');
  const boardInputs = Array.from(document.querySelectorAll('.board-input'));
  const board = document.getElementById('board');
  const celebrationCanvas = document.getElementById('celebration-canvas');
  const timer = document.getElementById('timer');
  const keyboard = document.querySelector('.keyboard');
  let lastFocusedInput = null;
  const attemptsContainer = document.getElementById('attempts-container');
  const noAttemptsMsg = document.getElementById('no-attempts-msg');
  const solvedBanner = document.getElementById('solved-banner');
  let celebrationStarted = false;
  const shareBtn = document.getElementById('share-btn');
  const shareModal = document.getElementById('share-modal');
  const shareTextArea = document.getElementById('share-text');
  const shareCopyBtn = document.getElementById('share-copy-btn');
  const shareCloseBtn = document.getElementById('share-close-btn');

  const openShareModal = (text) => {
    if (!shareModal || !shareTextArea) return;
    shareTextArea.value = text;
    shareModal.style.display = 'flex';
    setTimeout(() => {
      shareTextArea.focus();
      shareTextArea.select();
    }, 0);
  };
  window.openShareModal = openShareModal;

  const closeShareModal = () => {
    if (shareModal) shareModal.style.display = 'none';
  };

  if (shareCloseBtn) {
    shareCloseBtn.addEventListener('mousedown', (e) => {
      e.preventDefault();
      closeShareModal();
    });
  }

  if (shareModal) {
    shareModal.addEventListener('mousedown', (e) => {
      if (e.target.id === 'share-modal') {
        e.preventDefault();
        closeShareModal();
      }
    });
  }

  if (shareCopyBtn) {
    shareCopyBtn.addEventListener('mousedown', (e) => {
      e.preventDefault();
      if (!shareTextArea) return;
      shareTextArea.focus();
      shareTextArea.select();
      try {
        const ok = document.execCommand('copy');
        if (ok) {
          shareCopyBtn.textContent = 'Copied!';
          setTimeout(() => {
            shareCopyBtn.textContent = 'Copy';
          }, 1500);
        }
      } catch (err) {
        // If copy fails, keep text selected for manual copy
        console.error('Manual copy failed:', err);
      }
    });
  }

  if (shareBtn) {
    shareBtn.addEventListener('click', (e) => {
      e.preventDefault();
      const originalText = shareBtn.textContent;
      shareBtn.textContent = 'Sharing...';
      setTimeout(() => {
        shareBtn.textContent = originalText;
      }, 800);
      shareResult();
    });
  }

  const startCelebration = () => {
    if (!celebrationCanvas || celebrationStarted) return;
    celebrationStarted = true;
    celebrationCanvas.style.display = 'block';

    const ctx = celebrationCanvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const colors = ['#6aaa64', '#c9b458', '#b366cc', '#111827', '#3b82f6'];
    let particles = [];
    let startTime = performance.now();

    const resize = () => {
      celebrationCanvas.width = Math.floor(window.innerWidth * dpr);
      celebrationCanvas.height = Math.floor(window.innerHeight * dpr);
      celebrationCanvas.style.width = `${window.innerWidth}px`;
      celebrationCanvas.style.height = `${window.innerHeight}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };

    const spawnBurst = (x, y) => {
      const count = 40;
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 3;
        particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0,
          maxLife: 60 + Math.random() * 30,
          color: colors[Math.floor(Math.random() * colors.length)],
          size: 2 + Math.random() * 2
        });
      }
    };

    const tick = () => {
      const now = performance.now();
      const elapsed = now - startTime;
      ctx.clearRect(0, 0, celebrationCanvas.width, celebrationCanvas.height);
      if (elapsed < 2200 && Math.random() < 0.12) {
        const x = 60 + Math.random() * (window.innerWidth - 120);
        const y = 80 + Math.random() * (window.innerHeight * 0.4);
        spawnBurst(x, y);
      }

      particles = particles.filter(p => p.life < p.maxLife);
      for (const p of particles) {
        p.life += 1;
        p.vy += 0.04;
        p.x += p.vx;
        p.y += p.vy;
        const alpha = 1 - p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      if (elapsed < 2600 || particles.length > 0) {
        requestAnimationFrame(tick);
      } else {
        celebrationCanvas.style.display = 'none';
      }
    };

    resize();
    window.addEventListener('resize', resize);
    spawnBurst(window.innerWidth / 2, window.innerHeight / 3);
    requestAnimationFrame(tick);
  };

  const showSolvedUI = () => {
    if (solvedBanner) solvedBanner.style.display = 'block';
    startCelebration();
  };

  const appendAttempt = (guessRows, feedback) => {
    if (!attemptsContainer) return;
    if (noAttemptsMsg) noAttemptsMsg.style.display = 'none';

    const attemptGrid = document.createElement('div');
    attemptGrid.className = 'attempt-grid';

    for (let r = 0; r < 4; r++) {
      const rowEl = document.createElement('div');
      rowEl.className = 'attempt-row';

      const guessRow = guessRows[r] || '';
      const fbRow = feedback[r] || '____';

      for (let c = 0; c < 4; c++) {
        const letter = (guessRow[c] || '').toUpperCase();
        const fb = fbRow.charAt(c) || '_';
        const tile = document.createElement('div');
        let cls = 'absent';

        const revealedKey = `${r},${c}`;
        if (gameHistory.revealed.has(revealedKey)) {
          cls = 'revealed';
        } else if (fb === 'G') {
          cls = 'correct';
        } else if (fb === 'Y') {
          cls = 'present';
        } else if (fb === 'P') {
          cls = 'elsewhere';
        }

        tile.className = `attempt-tile ${cls}`;
        tile.textContent = letter;
        rowEl.appendChild(tile);
      }

      attemptGrid.appendChild(rowEl);
    }

    attemptsContainer.appendChild(attemptGrid);
  };

  // Apply feedback to the board display
  const applyFeedbackToBoard = (guessRows, feedback) => {
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        const idx = r * 4 + c;
        const tile = boardInputs[idx];
        
        // Skip revealed tiles - don't apply feedback to them
        const revealedKey = `${r},${c}`;
        if (gameHistory.revealed.has(revealedKey)) {
          continue;
        }
        
        const fbChar = feedback[r].charAt(c);  // feedback[r] is a string, so use charAt
        
        // Remove any existing feedback classes
        tile.classList.remove('correct', 'present', 'elsewhere', 'absent');
        
        // Apply the appropriate class and colors
        if (fbChar === 'G') {
          tile.classList.add('correct');
          tile.style.backgroundColor = 'rgb(16, 185, 129)';
          tile.style.color = '#ffffff';
        } else if (fbChar === 'Y') {
          tile.classList.add('present');
          tile.style.backgroundColor = 'rgb(168, 85, 247)';
          tile.style.color = '#ffffff';
        } else if (fbChar === 'P') {
          tile.classList.add('elsewhere');
          tile.style.backgroundColor = 'rgb(234, 179, 8)';
          tile.style.color = '#ffffff';
        } else {
          tile.classList.add('absent');
          tile.style.backgroundColor = '#ffffff';
          tile.style.color = '#6b7280';
        }
        
        // Keep greens locked; allow other tiles to be edited for next guess
        tile.contentEditable = fbChar === 'G' ? 'false' : 'true';
      }
    }
  };

  // Update keyboard colors based on all feedback
  const updateKeyboardColors = () => {
    const colorMap = {};
    const priority = { 'G': 3, 'Y': 2, 'P': 1, '_': 0 };
    
    // Aggregate feedback from all attempts
    if (gameHistory.feedbacks && gameHistory.feedbacks.length > 0) {
      for (let attemptIdx = 0; attemptIdx < gameHistory.feedbacks.length; attemptIdx++) {
        const fbRows = gameHistory.feedbacks[attemptIdx];
        const attemptRows = gameHistory.attempts[attemptIdx];
        
        for (let rowIdx = 0; rowIdx < fbRows.length; rowIdx++) {
          const fbRow = fbRows[rowIdx];  // fbRow is a string like "G_YP"
          const guessRow = attemptRows[rowIdx];  // guessRow is a string like "game"
          
          for (let c = 0; c < fbRow.length; c++) {
            const revealedKey = `${rowIdx},${c}`;
            if (gameHistory.revealed.has(revealedKey)) {
              continue;
            }
            const fbChar = fbRow.charAt(c);
            const letter = guessRow.charAt(c).toUpperCase();
            
            // Keep the highest priority feedback for each letter
            if (!colorMap[letter] || priority[fbChar] > priority[colorMap[letter]]) {
              colorMap[letter] = fbChar;
            }
          }
        }
      }
    }
    
    // Apply to keyboard
    keyboard.querySelectorAll('.key').forEach((key) => {
      const keyData = key.dataset.key;
      if (keyData && keyData.length === 1) {
        key.classList.remove('correct', 'present', 'elsewhere', 'absent');
        const fb = colorMap[keyData];
        if (fb) {
          if (fb === 'G') key.classList.add('correct');
          else if (fb === 'Y') key.classList.add('present');
          else if (fb === 'P') key.classList.add('elsewhere');
          else if (fb === '_') key.classList.add('absent');
        }
      }
    });
    
    forceColors();
  };

  // focus first editable tile
  const firstEditable = boardInputs.find(i => i.contentEditable === 'true');
  if (firstEditable) firstEditable.focus();
  lastFocusedInput = firstEditable;

  // remove shake class after animation
  if (board && board.classList.contains('shake')) {
    board.addEventListener('animationend', () => board.classList.remove('shake'));
  }

  const getNextEditable = (startIdx) => {
    let j = startIdx + 1;
    while (j < boardInputs.length && boardInputs[j].contentEditable === 'false') j++;
    return j < boardInputs.length ? j : null;
  };

  const getPrevEditable = (startIdx) => {
    let j = startIdx - 1;
    while (j >= 0 && boardInputs[j].contentEditable === 'false') j--;
    return j >= 0 ? j : null;
  };

  const getCurrentInput = () => {
    const active = document.activeElement;
    if (active && active.classList && active.classList.contains('board-input') && active.contentEditable === 'true') {
      lastFocusedInput = active;
      return active;
    }
    return lastFocusedInput && lastFocusedInput.contentEditable === 'true' ? lastFocusedInput : (boardInputs.find(i => i.contentEditable === 'true') || null);
  };

  const submitGuess = () => {
    // Trigger the form's submit event (which will run our event listener)
    // instead of calling form.submit() which bypasses the event
    form.dispatchEvent(new Event('submit', { bubbles: true }));
  };

  const updateKeyboardFromBoard = () => {
    if (!keyboard) return;
    
    // Use pre-computed keyboard state from server
    keyboard.querySelectorAll('.key').forEach((key) => {
      key.classList.remove('correct', 'present', 'elsewhere', 'absent');
      const k = key.dataset.key;
      if (!k || k.length !== 1) return;
      
      const state = keyboard_state[k];
      if (state) {
        if (state.fb === 'G') key.classList.add('correct');
        else if (state.fb === 'Y') key.classList.add('present');
        else if (state.fb === 'P') key.classList.add('elsewhere');
        else if (state.fb === '_') key.classList.add('absent');
      }
    });
  };

  // Force colors via inline styles (bypasses CSS, works on iOS)
  const forceColors = () => {
    // Read colors from CSS variables for easy future customization
    const root = document.documentElement;
    const getColor = (varName) => getComputedStyle(root).getPropertyValue(varName).trim();
    
    const boardColorMap = {
      'correct': { bg: getColor('--correct'), fg: getColor('--white') },
      'present': { bg: getColor('--present'), fg: getColor('--white') },
      'elsewhere': { bg: getColor('--elsewhere'), fg: getColor('--white') },
      'revealed': { bg: getColor('--revealed'), fg: getColor('--white') },
      'absent': { bg: getColor('--white'), fg: getColor('--muted') }
    };

    const keyboardColorMap = {
      'correct': { bg: getColor('--correct'), fg: getColor('--white'), border: 'none' },
      'present': { bg: getColor('--present'), fg: getColor('--white'), border: 'none' },
      'elsewhere': { bg: getColor('--elsewhere'), fg: getColor('--white'), border: 'none' },
      'absent': { bg: getColor('--keyboard-absent'), fg: getColor('--muted'), border: 'none' }
    };

    boardInputs.forEach((inp) => {
      for (const [className, colors] of Object.entries(boardColorMap)) {
        if (inp.classList.contains(className)) {
          inp.style.backgroundColor = colors.bg;
          inp.style.color = colors.fg;
          break;
        }
      }
    });

    keyboard.querySelectorAll('.key').forEach((key) => {
      for (const [className, colorProps] of Object.entries(keyboardColorMap)) {
        if (key.classList.contains(className)) {
          // Set color properties and preserve sizing/border
          key.style.backgroundColor = colorProps.bg;
          key.style.color = colorProps.fg;
          key.style.border = colorProps.border;
          key.style.boxShadow = '0 2px 6px rgba(15,23,42,0.08)';
          break;
        }
      }
    });
  };

  // Apply colors initially and whenever keyboard updates
  forceColors();

  boardInputs.forEach((inp, idx) => {
    if (inp.contentEditable === 'false') return;

    // initialize class based on data-fb
    const fb = inp.dataset.fb || '_';
    if (fb === 'G') { inp.classList.add('correct'); }
    else if (fb === 'Y') { inp.classList.add('present'); }
    else if (fb === 'P') { inp.classList.add('elsewhere'); }
    else { inp.classList.add('absent'); }

    // Position cursor at end when focused
    inp.addEventListener('focus', () => {
      lastFocusedInput = inp;
      // Move cursor to end for contenteditable - use setTimeout to ensure it happens after focus
      setTimeout(() => {
        const range = document.createRange();
        const sel = window.getSelection();
        if (inp.childNodes.length > 0) {
          range.setStartAfter(inp.childNodes[inp.childNodes.length - 1]);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
        } else {
          // Empty div - place cursor inside
          range.selectNodeContents(inp);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }, 0);
    });

    inp.addEventListener('input', (e) => {
      // Always take the last typed character (allows overwriting)
      let text = inp.textContent.toUpperCase().replace(/[^A-Z]/g, '');
      if (text.length > 1) {
        // User typed a new character while one existed - take the new one
        text = text[text.length - 1];
      }
      
      // Always update to ensure overwriting works
      inp.textContent = text;
      
      // Restore cursor position after changing text
      if (text) {
        const range = document.createRange();
        const sel = window.getSelection();
        if (inp.childNodes.length > 0) {
          range.setStartAfter(inp.childNodes[inp.childNodes.length - 1]);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }
      
      // if cleared, make white/black absent state so user can see empty white box
      if (!inp.textContent) {
        inp.classList.remove('present');
        inp.classList.remove('elsewhere');
        inp.classList.add('absent');
      } else {
        // user typed something â€” remove previous feedback coloring
        inp.classList.remove('absent');
        inp.classList.remove('correct');
        inp.classList.remove('present');
        inp.classList.remove('elsewhere');
        // Explicitly set white background while editing
        inp.style.backgroundColor = '#ffffff';
        inp.style.color = '#6b7280';
      }
      forceColors(); // Keep tile colors correct while typing
      // move to next editable tile
      const next = getNextEditable(idx);
      if (inp.textContent && next !== null) boardInputs[next].focus();
    });

    inp.addEventListener('keydown', (e) => {
      // If a letter key is pressed and there's already content, clear it first
      if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {
        if (inp.textContent.trim()) {
          inp.textContent = '';
        }
      }
      
      // Handle backspace - manually clear content for contenteditable divs
      if (e.key === 'Backspace') {
        e.preventDefault();
        if (inp.textContent) {
          // Text exists - delete it
          inp.textContent = '';
          inp.dispatchEvent(new Event('input', { bubbles: true }));
        } else {
          // No text - go to previous tile
          const prev = getPrevEditable(idx);
          if (prev !== null) boardInputs[prev].focus();
        }
      }
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        const prev = getPrevEditable(idx);
        if (prev !== null) boardInputs[prev].focus();
      }
      if (e.key === 'ArrowRight') {
        e.preventDefault();
        const next = getNextEditable(idx);
        if (next !== null) boardInputs[next].focus();
      }
      // Up arrow: move to same column in row above, skipping disabled tiles
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        const col = idx % 4;
        const row = Math.floor(idx / 4);
        if (row > 0) {
          let targetRow = row - 1;
          let targetIdx = targetRow * 4 + col;
          while (targetRow >= 0 && boardInputs[targetIdx].contentEditable === 'false') {
            targetRow--;
            targetIdx = targetRow * 4 + col;
          }
          if (targetRow >= 0 && targetIdx >= 0 && targetIdx < boardInputs.length) {
            boardInputs[targetIdx].focus();
          }
        }
      }
      // Down arrow: move to same column in row below, skipping disabled tiles
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        const col = idx % 4;
        const row = Math.floor(idx / 4);
        if (row < 3) {
          let targetRow = row + 1;
          let targetIdx = targetRow * 4 + col;
          while (targetRow <= 3 && boardInputs[targetIdx].contentEditable === 'false') {
            targetRow++;
            targetIdx = targetRow * 4 + col;
          }
          if (targetRow <= 3 && targetIdx < boardInputs.length) {
            boardInputs[targetIdx].focus();
          }
        }
      }
      // Submit on Enter
      if (e.key === 'Enter') {
        e.preventDefault();
        submitGuess();
      }
    });
  });

  if (keyboard) {
    keyboard.addEventListener('mousedown', (e) => {
      e.preventDefault();
      const btn = e.target.closest('.key');
      if (!btn) return;
      const key = btn.dataset.key;
      if (!key) return;
      const current = getCurrentInput();
      if (!current) return;
      const idx = boardInputs.indexOf(current);

      if (key === 'ENTER') {
        submitGuess();
        return;
      }
      if (key === 'DEL') {
        if (current.textContent) {
          current.textContent = '';
          current.dispatchEvent(new Event('input', { bubbles: true }));
        } else {
          const prev = getPrevEditable(idx);
          if (prev !== null) boardInputs[prev].focus();
        }
        return;
      }

      current.textContent = key;
      current.dispatchEvent(new Event('input', { bubbles: true }));
      // Blur after brief delay to prevent native keyboard, but keep focus visible momentarily
      setTimeout(() => current.blur(), 50);
    });
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    try {
      // Gather the current guess from board tiles
      const guessRows = [];
      for (let r = 0; r < 4; r++) {
        let txt = '';
        for (let c = 0; c < 4; c++) {
          const idx = r*4 + c;
          txt += (boardInputs[idx].textContent || ' ');
        }
        guessRows.push(txt.toLowerCase());
      }
      
      // Validate guess is 4 characters per row (can include spaces from blank tiles)
      const isValid = guessRows.every(row => row.length === 4);
      if (!isValid) {
        console.warn('âš ï¸ Invalid guess - must be 4 characters per row.');
        return;
      }

      // Compute feedback client-side
      const feedback = computeFullFeedback(guessRows, cube, gameHistory.revealed, gameHistory.attempts, gameHistory.feedbacks);
      
      // Add to local history
      gameHistory.attempts.push(guessRows);
      gameHistory.feedbacks.push(feedback);
      
      // Apply feedback to board immediately (instant visual feedback)
      applyFeedbackToBoard(guessRows, feedback, boardInputs);
      updateKeyboardColors();

      appendAttempt(guessRows, feedback);

      // Check solved state client-side
      const isSolvedNow = feedback.every(row => row === 'GGGG');
      if (isSolvedNow && !gameHistory.solved) {
        gameHistory.solved = true;
        showSolvedUI();
      }

      // Focus the first editable tile for the next guess
      const nextEditable = boardInputs.find(i => i.contentEditable === 'true');
      if (nextEditable) {
        nextEditable.focus();
        lastFocusedInput = nextEditable;
      }
      
      // Populate hidden form fields and submit to server
      for (let r = 0; r < 4; r++) {
        document.getElementById(`row${r}-hidden`).value = guessRows[r];
      }
      
      // Submit form to server (async). If offline or failed, queue for later.
      if (navigator && navigator.onLine === false) {
        OfflineQueue.add(guessRows, feedback);
        return;
      }

      fetch('{{ url_for("guess") }}', {
        method: 'POST',
        body: new FormData(form)
      }).then(response => {
        if (response.ok) {
          // Try to sync any pending guesses after successful submission
          syncPendingGuesses();
        } else {
          OfflineQueue.add(guessRows, feedback);
        }
      }).catch(() => {
        OfflineQueue.add(guessRows, feedback);
      });
    } catch (error) {
      console.error('ðŸ’¥ CRITICAL ERROR in form submit:', error);
      console.error(error.stack);
    }
  });

  updateKeyboardFromBoard();
  forceColors();

  // Initialize offline-first features
  console.log('ðŸš€ Wordcube game initialized');
  startSyncScheduler();
  
  // Sync any pending guesses that exist from before (e.g., page was closed while offline)
  syncPendingGuesses().catch(e => console.error('Initial sync failed:', e));

  if (timer) {
    const timerValue = document.getElementById('timer-value');
    const start = parseFloat(timer.dataset.start);
    const end = parseFloat(timer.dataset.end);

    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    };

    if (!isNaN(start)) {
      const update = () => {
        const now = isNaN(end) ? (Date.now() / 1000) : end;
        const elapsed = Math.max(0, now - start);
        timerValue.textContent = formatTime(elapsed);
      };

      update();
      if (isNaN(end)) {
        setInterval(update, 500);
      }
    }
  }

  if (gameHistory.solved) {
    showSolvedUI();
  }
});
</script>

<h3>Attempts</h3>
{% if attempts %}
  <div class="attempts" id="attempts-container">
  {% for _guess in attempts %}
    {% set aidx = loop.index0 %}
    <div class="attempt-grid">
      {% for r in range(4) %}
        <div class="attempt-row">
          {% set guess_row = attempts[aidx][r] %}
          {% set fb_row = feedbacks[aidx][r] %}
          {% for c in range(4) %}
            {% set letter = guess_row[c].upper() if guess_row|length > c else '' %}
            {% set fb = fb_row[c] if fb_row|length > c else '_' %}
            {% set cls = 'absent' %}
            {% if (r, c) in revealed %}
              {% set cls = 'revealed' %}
            {% elif fb == 'G' %}
              {% set cls = 'correct' %}
            {% elif fb == 'Y' %}
              {% set cls = 'present' %}
            {% elif fb == 'P' %}
              {% set cls = 'elsewhere' %}
            {% endif %}
            <div class="attempt-tile {{ cls }}">{{ letter }}</div>
          {% endfor %}
        </div>
      {% endfor %}
    </div>
  {% endfor %}
  </div>
{% else %}
  <div class="attempts" id="attempts-container"></div>
  <p id="no-attempts-msg">No attempts yet.</p>
{% endif %}

<script>
// Show welcome modal on first visit
function closeWelcome() {
  document.getElementById('welcome-modal').style.display = 'none';
  localStorage.setItem('wordcube-seen-welcome', 'true');
}

// Toggle welcome modal
function toggleWelcome() {
  const modal = document.getElementById('welcome-modal');
  modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
}

// Help button uses mousedown to prevent focus stealing
const helpBtn = document.getElementById('help-btn');
if (helpBtn) {
  helpBtn.addEventListener('mousedown', (e) => {
    e.preventDefault();
    toggleWelcome();
  });
}

// Modal Start Playing button
const modalBtn = document.querySelector('.modal-button');
if (modalBtn) {
  modalBtn.addEventListener('mousedown', (e) => {
    e.preventDefault();
    closeWelcome();
  });
}

// Close modal when clicking overlay (outside modal) - use mousedown
const welcomeModal = document.getElementById('welcome-modal');
if (welcomeModal) {
  welcomeModal.addEventListener('mousedown', (e) => {
    if (e.target.id === 'welcome-modal') {
      e.preventDefault();
      closeWelcome();
    }
  });
}

// Check if user has seen the welcome modal
if (!localStorage.getItem('wordcube-seen-welcome')) {
  document.getElementById('welcome-modal').style.display = 'flex';
}

function shareResult() {
  try {
  // Use live game history from client
  const revealedSet = gameHistory.revealed instanceof Set
    ? gameHistory.revealed
    : new Set({{ revealed | tojson }}.map(([r, c]) => `${r},${c}`));

  if (!gameHistory.attempts || gameHistory.attempts.length === 0) {
    alert('No attempts to share yet.');
    return;
  }

  // Create emoji grid
  let emojiGrid = '';
  for (let a = 0; a < gameHistory.attempts.length; a++) {
    const fb = gameHistory.feedbacks[a] || ['____', '____', '____', '____'];
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        // Check if this tile is a revealed (given) tile
        if (revealedSet.has(`${r},${c}`)) {
          emojiGrid += 'â¬›';
        } else {
          const fbRow = fb[r] || '____';
          const fbChar = fbRow.charAt(c) || '_';
          if (fbChar === 'G') {
            emojiGrid += 'ðŸŸ©';
          } else if (fbChar === 'Y') {
            emojiGrid += 'ðŸŸ¨';
          } else if (fbChar === 'P') {
            emojiGrid += 'ðŸŸª';
          } else {
            emojiGrid += 'â¬œ';
          }
        }
      }
      emojiGrid += '\n';
    }
    emojiGrid += '\n'; // Add extra newline between attempts
  }

  // Calculate time
  let endTime = {{ end_time | tojson }};
  if (!endTime) {
    endTime = Date.now() / 1000; // Use current time if end_time not set
  }
  const startTime = {{ start_time | tojson }} || (Date.now() / 1000);
  const timeSeconds = (endTime - startTime);
  const mins = Math.floor(timeSeconds / 60);
  const secs = Math.floor(timeSeconds % 60);
  const timeStr = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;

  // Format attempts count
  const attemptsCount = gameHistory.attempts.length;

  // Create share text
  const gameMode = '{{ game_mode }}';
  let title = gameMode === 'daily' ? 'Daily Cube' : 'Custom Game';
  const shareText = `Word Cube ${title}\n\n${emojiGrid}\nAttempts: ${attemptsCount}\nTime: ${timeStr}\n\nPlay at: wordcubegame.com`;

  const showCopied = () => {
    const btn = document.getElementById('share-btn');
    if (!btn) return;
    const originalText = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(() => {
      btn.textContent = originalText;
    }, 2000);
  };

  const execCopy = () => {
    const textarea = document.createElement('textarea');
    textarea.value = shareText;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    textarea.style.left = '-9999px';
    textarea.setAttribute('readonly', '');
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    let success = false;
    try {
      success = document.execCommand('copy');
    } catch (e) {
      success = false;
    }
    document.body.removeChild(textarea);
    return success;
  };

  // Prefer Clipboard API on HTTPS, fall back to execCommand
  if (window.isSecureContext && navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(shareText).then(() => {
      showCopied();
    }).catch(() => {
      const ok = execCopy();
      if (ok) {
        showCopied();
      } else {
        alert('Copy failed. Please try again.');
      }
    });
    return;
  }

  // Non-HTTPS: try execCommand as best-effort
  if (execCopy()) {
    showCopied();
    return;
  }

  alert('Copy failed. Please try again.');
  } catch (err) {
    console.error('Share failed:', err);
    alert('Share failed. Please try again.');
  }
}
</script>

{% endblock %}
