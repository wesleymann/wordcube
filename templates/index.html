{% extends "base.html" %}
{% block content %}

<!-- Welcome Modal -->
<div id="welcome-modal" class="modal-overlay" style="display: none;">
  <div class="modal">
    <h2>How to Play</h2>
    <p>Fill in the 4x4 grid with words. Some letters are revealed to help you start.</p>
    <p><strong>Feedback colors:</strong></p>
    <p><span class="example-tile correct">G</span> <strong>Green:</strong> Correct letter in the right position</p>
    <p><span class="example-tile present">Y</span> <strong>Yellow:</strong> Letter exists in the same row or column, but wrong position</p>
    <p><span class="example-tile elsewhere">P</span> <strong>Purple:</strong> Letter exists elsewhere on the grid (not in same row/column)</p>
    <p>Good luck!</p>
    <button onclick="closeWelcome()">Start Playing</button>
  </div>
</div>

<div class="game-meta">
  <button class="help-button" onclick="toggleWelcome()" aria-label="Show help">?</button>
  <div class="game-links">
    <a href="{{ url_for('new_game') }}">Play Random Cube</a>
    <span class="sep">|</span>
    <a href="{{ url_for('daily_game') }}">Return to Daily</a>
    <span class="sep">|</span>
    <a href="{{ url_for('reveal_answer') }}">Reveal Answer</a>
  </div>
</div>

<h3 class="board-title">
  {% if game_mode == 'daily' %}
    Daily Cube{% if daily_date_display %} • {{ daily_date_display }}{% endif %}
  {% else %}
    Custom Game
  {% endif %}
</h3>
{# Compute last attempt/feedback if present #}
{% set last_attempt = attempts[-1] if attempts else None %}
{% set last_feedback = feedbacks[-1] if feedbacks else None %}

<div id="board" class="cube-grid {% if shake %}shake{% endif %}">
  {% for r in range(4) %}
    <div class="cube-row">
      {% for c in range(4) %}
        {% set ch = cube[r][c].upper() %}
        {% if (r, c) in revealed %}
          <input class="board-input revealed" value="{{ ch }}" disabled>
        {% else %}
          {# If there was a last attempt, use its letter and feedback for this cell #}
          {% if last_attempt and last_feedback %}
            {% set guessed_row = last_attempt[r] %}
            {% set fb_row = last_feedback[r] %}
            {% set letter = guessed_row[c].upper() if guessed_row|length > c else '' %}
            {% set fbchar = fb_row[c] if fb_row|length > c else '_' %}
            {% if fbchar == 'G' %}
              <input class="board-input correct" value="{{ letter }}" disabled data-fb="G">
            {% elif fbchar == 'Y' %}
              <input class="board-input present" maxlength="1" value="{{ letter }}" data-fb="Y">
            {% elif fbchar == 'P' %}
              <input class="board-input elsewhere" maxlength="1" value="{{ letter }}" data-fb="P">
            {% else %}
              {# show the previous guessed letter in black so it's visible on next guess #}
              <input class="board-input absent" maxlength="1" value="{{ letter }}" data-fb="_">
            {% endif %}
          {% else %}
            <input class="board-input" maxlength="1" value="" data-fb="_">
          {% endif %}
        {% endif %}
      {% endfor %}
    </div>
  {% endfor %}
</div>

{% if solved %}
  <p class="success">Solved! Well done.</p>
{% endif %}

<div class="timer" id="timer" data-start="{{ start_time|default('', true) }}" data-end="{{ end_time|default('', true) }}">
  Time: <span id="timer-value">00:00</span>
</div>

{% if solved %}
  <canvas id="celebration-canvas" aria-hidden="true"></canvas>
{% endif %}

<form id="guess-form" method="post" action="{{ url_for('guess') }}">
  <!-- hidden row fields populated by JS from board inputs -->
  {% for i in range(4) %}
    <input type="hidden" name="row{{ i }}" id="row{{ i }}-hidden">
  {% endfor %}
</form>

<div class="keyboard" aria-label="On-screen keyboard">
  <div class="key-row">
    {% for k in ['Q','W','E','R','T','Y','U','I','O','P'] %}
      <button type="button" class="key" data-key="{{ k }}">{{ k }}</button>
    {% endfor %}
  </div>
  <div class="key-row">
    {% for k in ['A','S','D','F','G','H','J','K','L'] %}
      <button type="button" class="key" data-key="{{ k }}">{{ k }}</button>
    {% endfor %}
  </div>
  <div class="key-row">
    <button type="button" class="key key-wide" data-key="ENTER">Enter</button>
    {% for k in ['Z','X','C','V','B','N','M'] %}
      <button type="button" class="key" data-key="{{ k }}">{{ k }}</button>
    {% endfor %}
    <button type="button" class="key key-wide" data-key="DEL">Del</button>
  </div>
</div>

<script>
// Embed game history for keyboard persistence
const gameHistory = {
  attempts: {{ attempts | tojson }},
  feedbacks: {{ feedbacks | tojson }},
  revealed: new Set({{ (revealed | list) | tojson }}.map(pair => `${pair[0]},${pair[1]}`))
};

document.addEventListener('DOMContentLoaded', function(){
  const form = document.getElementById('guess-form');
  const boardInputs = Array.from(document.querySelectorAll('.board-input'));
  const board = document.getElementById('board');
  const celebrationCanvas = document.getElementById('celebration-canvas');
  const timer = document.getElementById('timer');
  const keyboard = document.querySelector('.keyboard');
  let lastFocusedInput = null;

  // focus first editable tile
  const firstEditable = boardInputs.find(i => !i.disabled);
  if (firstEditable) firstEditable.focus();
  lastFocusedInput = firstEditable;

  // remove shake class after animation
  if (board && board.classList.contains('shake')) {
    board.addEventListener('animationend', () => board.classList.remove('shake'));
  }

  const getNextEditable = (startIdx) => {
    let j = startIdx + 1;
    while (j < boardInputs.length && boardInputs[j].disabled) j++;
    return j < boardInputs.length ? j : null;
  };

  const getPrevEditable = (startIdx) => {
    let j = startIdx - 1;
    while (j >= 0 && boardInputs[j].disabled) j--;
    return j >= 0 ? j : null;
  };

  const getCurrentInput = () => {
    const active = document.activeElement;
    if (active && active.classList && active.classList.contains('board-input') && !active.disabled) {
      lastFocusedInput = active;
      return active;
    }
    return lastFocusedInput && !lastFocusedInput.disabled ? lastFocusedInput : (boardInputs.find(i => !i.disabled) || null);
  };

  const submitGuess = () => {
    for (let r = 0; r < 4; r++) {
      let txt = '';
      for (let c = 0; c < 4; c++) {
        const idx = r*4 + c;
        txt += (boardInputs[idx].value || ' ');
      }
      document.getElementById(`row${r}-hidden`).value = txt.toLowerCase();
    }
    form.submit();
  };

  const updateKeyboardFromBoard = () => {
    if (!keyboard) return;
    const priority = { 'G': 3, 'Y': 2, 'P': 1, '_': 0 };
    const letterState = {};
    
    // First, process all historical attempts (from previous submissions)
    if (gameHistory && gameHistory.attempts && gameHistory.feedbacks && gameHistory.attempts.length > 0) {
      for (let attemptIdx = 0; attemptIdx < gameHistory.attempts.length; attemptIdx++) {
        const attempt = gameHistory.attempts[attemptIdx];
        const feedback = gameHistory.feedbacks[attemptIdx];
        
        // Each attempt is an array of 4 rows
        for (let rowIdx = 0; rowIdx < attempt.length; rowIdx++) {
          const guessRow = attempt[rowIdx];
          const fbRow = feedback[rowIdx];
          
          for (let colIdx = 0; colIdx < guessRow.length; colIdx++) {
            // Skip revealed positions - they shouldn't count toward keyboard feedback
            const posKey = `${rowIdx},${colIdx}`;
            if (gameHistory.revealed && gameHistory.revealed.has(posKey)) {
              continue;
            }
            
            const letter = guessRow[colIdx].toUpperCase();
            const fb = fbRow[colIdx] || '_';
            if (!letter || letter === ' ') continue;
            
            const current = letterState[letter] || { fb: null, p: -1 };
            const p = priority[fb] !== undefined ? priority[fb] : -1;
            if (p > current.p) {
              letterState[letter] = { fb, p };
            }
          }
        }
      }
    }
    
    // Then, process current board inputs (excluding revealed tiles)
    // This handles the current guess being typed
    boardInputs.forEach((inp) => {
      if (inp.disabled) return; // skip revealed and locked tiles
      const letter = (inp.value || '').toUpperCase();
      if (!letter) return; // skip empty tiles
      
      const fb = inp.dataset.fb || '_';
      const current = letterState[letter] || { fb: null, p: -1 };
      const p = priority[fb] !== undefined ? priority[fb] : -1;
      if (p > current.p) {
        letterState[letter] = { fb, p };
      }
    });

    keyboard.querySelectorAll('.key').forEach((key) => {
      key.classList.remove('correct', 'present', 'elsewhere', 'absent');
      const k = key.dataset.key;
      if (!k || k.length !== 1) return;
      const state = letterState[k];
      if (state) {
        if (state.fb === 'G') key.classList.add('correct');
        else if (state.fb === 'Y') key.classList.add('present');
        else if (state.fb === 'P') key.classList.add('elsewhere');
        else if (state.fb === '_') key.classList.add('absent');
      }
    });
  };

  // Force colors via inline styles (bypasses CSS, works on iOS)
  const forceColors = () => {
    const boardColorMap = {
      'correct': { bg: 'rgb(16, 185, 129)', fg: '#ffffff' },
      'present': { bg: 'rgb(234, 179, 8)', fg: '#ffffff' },
      'elsewhere': { bg: 'rgb(168, 85, 247)', fg: '#ffffff' },
      'revealed': { bg: 'rgb(0, 0, 0)', fg: '#ffffff' },
      'absent': { bg: '#ffffff', fg: '#6b7280' }
    };

    const keyboardColorMap = {
      'correct': { bg: 'rgb(16, 185, 129)', fg: '#ffffff', border: 'none' },
      'present': { bg: 'rgb(234, 179, 8)', fg: '#ffffff', border: 'none' },
      'elsewhere': { bg: 'rgb(168, 85, 247)', fg: '#ffffff', border: 'none' },
      'absent': { bg: '#d1d5db', fg: '#6b7280', border: '1px solid #e5e7eb' }
    };

    boardInputs.forEach((inp) => {
      for (const [className, colors] of Object.entries(boardColorMap)) {
        if (inp.classList.contains(className)) {
          inp.style.backgroundColor = colors.bg;
          inp.style.color = colors.fg;
          break;
        }
      }
    });

    keyboard.querySelectorAll('.key').forEach((key) => {
      for (const [className, colorProps] of Object.entries(keyboardColorMap)) {
        if (key.classList.contains(className)) {
          // Set color properties and preserve sizing/border
          key.style.backgroundColor = colorProps.bg;
          key.style.color = colorProps.fg;
          key.style.border = colorProps.border;
          key.style.boxShadow = '0 2px 6px rgba(15,23,42,0.08)';
          break;
        }
      }
    });
  };

  // Apply colors initially and whenever keyboard updates
  forceColors();

  boardInputs.forEach((inp, idx) => {
    if (inp.disabled) return;

    // initialize class based on data-fb
    const fb = inp.dataset.fb || '_';
    if (fb === 'G') { inp.classList.add('correct'); }
    else if (fb === 'Y') { inp.classList.add('present'); }
    else if (fb === 'P') { inp.classList.add('elsewhere'); }
    else { inp.classList.add('absent'); }

    // Position cursor after existing letter when focused
    inp.addEventListener('focus', () => {
      lastFocusedInput = inp;
      if (inp.value) {
        // Use setTimeout to ensure this happens after browser's default focus behavior
        setTimeout(() => {
          inp.setSelectionRange(inp.value.length, inp.value.length);
        }, 0);
      }
    });

    // Handle mouse clicks specifically - browser places cursor where clicked
    inp.addEventListener('click', () => {
      if (inp.value) {
        setTimeout(() => {
          inp.setSelectionRange(inp.value.length, inp.value.length);
        }, 0);
      }
    });

    inp.addEventListener('input', () => {
      inp.value = inp.value.toUpperCase().replace(/[^A-Z]/g, '');
      // if cleared, make white/black absent state so user can see empty white box
      if (!inp.value) {
        inp.classList.remove('present');
        inp.classList.remove('elsewhere');
        inp.classList.add('absent');
      } else {
        // user typed something — remove previous feedback coloring
        inp.classList.remove('absent');
        inp.classList.remove('present');
        inp.classList.remove('elsewhere');
      }
      forceColors(); // Keep tile colors correct while typing
      // move to next editable tile
      const next = getNextEditable(idx);
      if (inp.value && next !== null) boardInputs[next].focus();
    });

    inp.addEventListener('keydown', (e) => {
      // Allow backspace to delete normally when text is selected
      if (e.key === 'Backspace') {
        if (inp.value) {
          // Text exists - allow default backspace behavior (delete)
          return;
        } else {
          // No text - go to previous tile
          const prev = getPrevEditable(idx);
          if (prev !== null) boardInputs[prev].focus();
        }
      }
      if (e.key === 'ArrowLeft') {
        const prev = getPrevEditable(idx);
        if (prev !== null) boardInputs[prev].focus();
      }
      if (e.key === 'ArrowRight') {
        const next = getNextEditable(idx);
        if (next !== null) boardInputs[next].focus();
      }
      // Up arrow: move to same column in row above, skipping disabled tiles
      if (e.key === 'ArrowUp') {
        const col = idx % 4;
        const row = Math.floor(idx / 4);
        if (row > 0) {
          let targetRow = row - 1;
          let targetIdx = targetRow * 4 + col;
          while (targetRow >= 0 && boardInputs[targetIdx].disabled) {
            targetRow--;
            targetIdx = targetRow * 4 + col;
          }
          if (targetRow >= 0 && targetIdx >= 0 && targetIdx < boardInputs.length) {
            boardInputs[targetIdx].focus();
          }
        }
      }
      // Down arrow: move to same column in row below, skipping disabled tiles
      if (e.key === 'ArrowDown') {
        const col = idx % 4;
        const row = Math.floor(idx / 4);
        if (row < 3) {
          let targetRow = row + 1;
          let targetIdx = targetRow * 4 + col;
          while (targetRow <= 3 && boardInputs[targetIdx].disabled) {
            targetRow++;
            targetIdx = targetRow * 4 + col;
          }
          if (targetRow <= 3 && targetIdx < boardInputs.length) {
            boardInputs[targetIdx].focus();
          }
        }
      }
      // Submit on Enter
      if (e.key === 'Enter') {
        e.preventDefault();
        submitGuess();
      }
    });
  });

  if (keyboard) {
    keyboard.addEventListener('click', (e) => {
      const btn = e.target.closest('.key');
      if (!btn) return;
      const key = btn.dataset.key;
      if (!key) return;
      const current = getCurrentInput();
      if (!current) return;
      const idx = boardInputs.indexOf(current);

      if (key === 'ENTER') {
        submitGuess();
        return;
      }
      if (key === 'DEL') {
        if (current.value) {
          current.value = '';
          current.dispatchEvent(new Event('input', { bubbles: true }));
        } else {
          const prev = getPrevEditable(idx);
          if (prev !== null) boardInputs[prev].focus();
        }
        return;
      }

      current.value = key;
      current.dispatchEvent(new Event('input', { bubbles: true }));
    });
  }

  form.addEventListener('submit', (e) => {
    for (let r = 0; r < 4; r++) {
      let txt = '';
      for (let c = 0; c < 4; c++) {
        const idx = r*4 + c;
        txt += (boardInputs[idx].value || ' ');
      }
      // Keep spaces as-is, only lowercase letters (don't remove spaces)
      document.getElementById(`row${r}-hidden`).value = txt.toLowerCase();
    }
    // allow form to submit normally
  });

  updateKeyboardFromBoard();
  forceColors();

  if (timer) {
    const timerValue = document.getElementById('timer-value');
    const start = parseFloat(timer.dataset.start);
    const end = parseFloat(timer.dataset.end);

    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    };

    if (!isNaN(start)) {
      const update = () => {
        const now = isNaN(end) ? (Date.now() / 1000) : end;
        const elapsed = Math.max(0, now - start);
        timerValue.textContent = formatTime(elapsed);
      };

      update();
      if (isNaN(end)) {
        setInterval(update, 500);
      }
    }
  }

  if (celebrationCanvas) {
    const ctx = celebrationCanvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const colors = ['#6aaa64', '#c9b458', '#b366cc', '#111827', '#3b82f6'];
    let particles = [];
    let startTime = performance.now();

    const resize = () => {
      celebrationCanvas.width = Math.floor(window.innerWidth * dpr);
      celebrationCanvas.height = Math.floor(window.innerHeight * dpr);
      celebrationCanvas.style.width = `${window.innerWidth}px`;
      celebrationCanvas.style.height = `${window.innerHeight}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };

    const spawnBurst = (x, y) => {
      const count = 40;
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 3;
        particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0,
          maxLife: 60 + Math.random() * 30,
          color: colors[Math.floor(Math.random() * colors.length)],
          size: 2 + Math.random() * 2
        });
      }
    };

    const tick = () => {
      const now = performance.now();
      const elapsed = now - startTime;
      ctx.clearRect(0, 0, celebrationCanvas.width, celebrationCanvas.height);
      if (elapsed < 2200 && Math.random() < 0.12) {
        const x = 60 + Math.random() * (window.innerWidth - 120);
        const y = 80 + Math.random() * (window.innerHeight * 0.4);
        spawnBurst(x, y);
      }

      particles = particles.filter(p => p.life < p.maxLife);
      for (const p of particles) {
        p.life += 1;
        p.vy += 0.04;
        p.x += p.vx;
        p.y += p.vy;
        const alpha = 1 - p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      if (elapsed < 2600 || particles.length > 0) {
        requestAnimationFrame(tick);
      } else {
        celebrationCanvas.style.display = 'none';
      }
    };

    resize();
    window.addEventListener('resize', resize);
    spawnBurst(window.innerWidth / 2, window.innerHeight / 3);
    requestAnimationFrame(tick);
  }
});
</script>

<h3>Attempts</h3>
{% if attempts %}
  <div class="attempts">
  {% for _guess in attempts %}
    {% set aidx = loop.index0 %}
    <div class="attempt-grid">
      {% for r in range(4) %}
        <div class="attempt-row">
          {% set guess_row = attempts[aidx][r] %}
          {% set fb_row = feedbacks[aidx][r] %}
          {% for c in range(4) %}
            {% set letter = guess_row[c].upper() if guess_row|length > c else '' %}
            {% set fb = fb_row[c] if fb_row|length > c else '_' %}
            {% set cls = 'absent' %}
            {% if (r, c) in revealed %}
              {% set cls = 'revealed' %}
            {% elif fb == 'G' %}
              {% set cls = 'correct' %}
            {% elif fb == 'Y' %}
              {% set cls = 'present' %}
            {% elif fb == 'P' %}
              {% set cls = 'elsewhere' %}
            {% endif %}
            <div class="attempt-tile {{ cls }}">{{ letter }}</div>
          {% endfor %}
        </div>
      {% endfor %}
    </div>
  {% endfor %}
  </div>
{% else %}
  <p>No attempts yet.</p>
{% endif %}

<script>
// Show welcome modal on first visit
function closeWelcome() {
  document.getElementById('welcome-modal').style.display = 'none';
  localStorage.setItem('wordcube-seen-welcome', 'true');
}

// Toggle welcome modal
function toggleWelcome() {
  const modal = document.getElementById('welcome-modal');
  modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
}

// Close modal when clicking overlay (outside modal)
document.getElementById('welcome-modal').addEventListener('click', (e) => {
  if (e.target.id === 'welcome-modal') {
    closeWelcome();
  }
});

// Check if user has seen the welcome modal
if (!localStorage.getItem('wordcube-seen-welcome')) {
  document.getElementById('welcome-modal').style.display = 'flex';
}
</script>

{% endblock %}
