{% extends "base.html" %}
{% block content %}

<!-- Welcome Modal -->
<div id="welcome-modal" class="modal-overlay" style="display: none;">
  <div class="modal">
    <h2>How to Play</h2>
    <p>Fill in the 4x4 grid with words. Some letters are revealed to help you start.</p>
    <p><strong>Feedback colors:</strong></p>
    <p><span class="example-tile correct">G</span> <strong>Green:</strong> Correct letter in the right position</p>
    <p><span class="example-tile present">P</span> <strong>Purple:</strong> Letter exists in the same row or column, but wrong position</p>
    <p><span class="example-tile elsewhere">Y</span> <strong>Yellow:</strong> Letter exists elsewhere on the grid (not in same row/column)</p>
    <p>Good luck!</p>
    <button onclick="closeWelcome()">Start Playing</button>
  </div>
</div>

<div class="game-meta">
  <button class="help-button" onclick="toggleWelcome()" aria-label="Show help">?</button>
  <div class="game-links">
    <a href="{{ url_for('new_game') }}">Play Random Cube</a>
    <span class="sep">|</span>
    <a href="{{ url_for('daily_game') }}">Return to Daily</a>
    <span class="sep">|</span>
    <a href="{{ url_for('reveal_answer') }}">Reveal Answer</a>
  </div>
</div>

<h3 class="board-title">
  {% if game_mode == 'daily' %}
    Daily Cube{% if daily_date_display %} â€¢ {{ daily_date_display }}{% endif %}
  {% else %}
    Custom Game
  {% endif %}
</h3>
{# Compute last attempt/feedback if present #}
{% set last_attempt = attempts[-1] if attempts else None %}
{% set last_feedback = feedbacks[-1] if feedbacks else None %}

<div id="board" class="cube-grid {% if shake %}shake{% endif %}">
  {% for r in range(4) %}
    <div class="cube-row">
      {% for c in range(4) %}
        {% set ch = cube[r][c].upper() %}
        {% if (r, c) in revealed %}
          <div class="board-input revealed" contenteditable="false">{{ ch }}</div>
        {% else %}
          {# If there was a last attempt, use its letter and feedback for this cell #}
          {% if last_attempt and last_feedback %}
            {% set guessed_row = last_attempt[r] %}
            {% set fb_row = last_feedback[r] %}
            {% set letter = guessed_row[c].upper() if guessed_row|length > c else '' %}
            {% set fbchar = fb_row[c] if fb_row|length > c else '_' %}
            {% if fbchar == 'G' %}
              <div class="board-input correct" contenteditable="false" data-fb="G">{{ letter }}</div>
            {% elif fbchar == 'Y' %}
              <div class="board-input present" contenteditable="true" data-fb="Y">{{ letter }}</div>
            {% elif fbchar == 'P' %}
              <div class="board-input elsewhere" contenteditable="true" data-fb="P">{{ letter }}</div>
            {% else %}
              {# show the previous guessed letter in black so it's visible on next guess #}
              <div class="board-input absent" contenteditable="true" data-fb="_">{{ letter }}</div>
            {% endif %}
          {% else %}
            <div class="board-input" contenteditable="true" data-fb="_"></div>
          {% endif %}
        {% endif %}
      {% endfor %}
    </div>
  {% endfor %}
</div>

{% if solved %}
  <p class="success">Solved! Well done.</p>
  <button id="share-btn" onclick="shareResult()" style="width: 100%; padding: 10px; background: #111827; color: #ffffff; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; margin-top: 12px;">Share Result</button>
{% endif %}

<div class="timer" id="timer" data-start="{{ start_time|default('', true) }}" data-end="{{ end_time|default('', true) }}">
  Time: <span id="timer-value">00:00</span>
</div>

{% if solved %}
  <canvas id="celebration-canvas" aria-hidden="true"></canvas>
{% endif %}

<form id="guess-form" method="post" action="{{ url_for('guess') }}">
  <!-- hidden row fields populated by JS from board inputs -->
  {% for i in range(4) %}
    <input type="hidden" name="row{{ i }}" id="row{{ i }}-hidden">
  {% endfor %}
</form>

<div class="keyboard" aria-label="On-screen keyboard">
  <div class="key-row">
    {% for k in ['Q','W','E','R','T','Y','U','I','O','P'] %}
      <button type="button" class="key" data-key="{{ k }}" tabindex="-1">{{ k }}</button>
    {% endfor %}
  </div>
  <div class="key-row">
    {% for k in ['A','S','D','F','G','H','J','K','L'] %}
      <button type="button" class="key" data-key="{{ k }}" tabindex="-1">{{ k }}</button>
    {% endfor %}
  </div>
  <div class="key-row">
    <button type="button" class="key key-wide" data-key="ENTER" tabindex="-1">Enter</button>
    {% for k in ['Z','X','C','V','B','N','M'] %}
      <button type="button" class="key" data-key="{{ k }}" tabindex="-1">{{ k }}</button>
    {% endfor %}
    <button type="button" class="key key-wide" data-key="DEL" tabindex="-1">Del</button>
  </div>
</div>

<script>
// Use pre-computed keyboard state from server instead of storing all attempts
const keyboard_state = {{ keyboard_state | tojson }};
const gameHistory = {
  attempts: [],  // Empty - we don't need it anymore
  feedbacks: [],  // Empty - we don't need it anymore
  revealed: new Set({{ (revealed | list) | tojson }}.map(pair => `${pair[0]},${pair[1]}`))
};

document.addEventListener('DOMContentLoaded', function(){
  const form = document.getElementById('guess-form');
  const boardInputs = Array.from(document.querySelectorAll('.board-input'));
  const board = document.getElementById('board');
  const celebrationCanvas = document.getElementById('celebration-canvas');
  const timer = document.getElementById('timer');
  const keyboard = document.querySelector('.keyboard');
  let lastFocusedInput = null;

  // focus first editable tile
  const firstEditable = boardInputs.find(i => i.contentEditable === 'true');
  if (firstEditable) firstEditable.focus();
  lastFocusedInput = firstEditable;

  // remove shake class after animation
  if (board && board.classList.contains('shake')) {
    board.addEventListener('animationend', () => board.classList.remove('shake'));
  }

  const getNextEditable = (startIdx) => {
    let j = startIdx + 1;
    while (j < boardInputs.length && boardInputs[j].contentEditable === 'false') j++;
    return j < boardInputs.length ? j : null;
  };

  const getPrevEditable = (startIdx) => {
    let j = startIdx - 1;
    while (j >= 0 && boardInputs[j].contentEditable === 'false') j--;
    return j >= 0 ? j : null;
  };

  const getCurrentInput = () => {
    const active = document.activeElement;
    if (active && active.classList && active.classList.contains('board-input') && active.contentEditable === 'true') {
      lastFocusedInput = active;
      return active;
    }
    return lastFocusedInput && lastFocusedInput.contentEditable === 'true' ? lastFocusedInput : (boardInputs.find(i => i.contentEditable === 'true') || null);
  };

  const submitGuess = () => {
    for (let r = 0; r < 4; r++) {
      let txt = '';
      for (let c = 0; c < 4; c++) {
        const idx = r*4 + c;
        txt += (boardInputs[idx].textContent || ' ');
      }
      document.getElementById(`row${r}-hidden`).value = txt.toLowerCase();
    }
    form.submit();
  };

  const updateKeyboardFromBoard = () => {
    if (!keyboard) return;
    
    // Use pre-computed keyboard state from server
    keyboard.querySelectorAll('.key').forEach((key) => {
      key.classList.remove('correct', 'present', 'elsewhere', 'absent');
      const k = key.dataset.key;
      if (!k || k.length !== 1) return;
      
      const state = keyboard_state[k];
      if (state) {
        if (state.fb === 'G') key.classList.add('correct');
        else if (state.fb === 'Y') key.classList.add('present');
        else if (state.fb === 'P') key.classList.add('elsewhere');
        else if (state.fb === '_') key.classList.add('absent');
      }
    });
  };

  // Force colors via inline styles (bypasses CSS, works on iOS)
  const forceColors = () => {
    // Read colors from CSS variables for easy future customization
    const root = document.documentElement;
    const getColor = (varName) => getComputedStyle(root).getPropertyValue(varName).trim();
    
    const boardColorMap = {
      'correct': { bg: getColor('--correct'), fg: getColor('--white') },
      'present': { bg: getColor('--present'), fg: getColor('--white') },
      'elsewhere': { bg: getColor('--elsewhere'), fg: getColor('--white') },
      'revealed': { bg: getColor('--revealed'), fg: getColor('--white') },
      'absent': { bg: getColor('--white'), fg: getColor('--muted') }
    };

    const keyboardColorMap = {
      'correct': { bg: getColor('--correct'), fg: getColor('--white'), border: 'none' },
      'present': { bg: getColor('--present'), fg: getColor('--white'), border: 'none' },
      'elsewhere': { bg: getColor('--elsewhere'), fg: getColor('--white'), border: 'none' },
      'absent': { bg: getColor('--keyboard-absent'), fg: getColor('--muted'), border: 'none' }
    };

    boardInputs.forEach((inp) => {
      for (const [className, colors] of Object.entries(boardColorMap)) {
        if (inp.classList.contains(className)) {
          inp.style.backgroundColor = colors.bg;
          inp.style.color = colors.fg;
          break;
        }
      }
    });

    keyboard.querySelectorAll('.key').forEach((key) => {
      for (const [className, colorProps] of Object.entries(keyboardColorMap)) {
        if (key.classList.contains(className)) {
          // Set color properties and preserve sizing/border
          key.style.backgroundColor = colorProps.bg;
          key.style.color = colorProps.fg;
          key.style.border = colorProps.border;
          key.style.boxShadow = '0 2px 6px rgba(15,23,42,0.08)';
          break;
        }
      }
    });
  };

  // Apply colors initially and whenever keyboard updates
  forceColors();

  boardInputs.forEach((inp, idx) => {
    if (inp.contentEditable === 'false') return;

    // initialize class based on data-fb
    const fb = inp.dataset.fb || '_';
    if (fb === 'G') { inp.classList.add('correct'); }
    else if (fb === 'Y') { inp.classList.add('present'); }
    else if (fb === 'P') { inp.classList.add('elsewhere'); }
    else { inp.classList.add('absent'); }

    // Position cursor at end when focused
    inp.addEventListener('focus', () => {
      lastFocusedInput = inp;
      // Move cursor to end for contenteditable - use setTimeout to ensure it happens after focus
      setTimeout(() => {
        const range = document.createRange();
        const sel = window.getSelection();
        if (inp.childNodes.length > 0) {
          range.setStartAfter(inp.childNodes[inp.childNodes.length - 1]);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
        } else {
          // Empty div - place cursor inside
          range.selectNodeContents(inp);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }, 0);
    });

    inp.addEventListener('input', (e) => {
      // Always take the last typed character (allows overwriting)
      let text = inp.textContent.toUpperCase().replace(/[^A-Z]/g, '');
      if (text.length > 1) {
        // User typed a new character while one existed - take the new one
        text = text[text.length - 1];
      }
      
      // Always update to ensure overwriting works
      inp.textContent = text;
      
      // Restore cursor position after changing text
      if (text) {
        const range = document.createRange();
        const sel = window.getSelection();
        if (inp.childNodes.length > 0) {
          range.setStartAfter(inp.childNodes[inp.childNodes.length - 1]);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }
      
      // if cleared, make white/black absent state so user can see empty white box
      if (!inp.textContent) {
        inp.classList.remove('present');
        inp.classList.remove('elsewhere');
        inp.classList.add('absent');
      } else {
        // user typed something â€” remove previous feedback coloring
        inp.classList.remove('absent');
        inp.classList.remove('correct');
        inp.classList.remove('present');
        inp.classList.remove('elsewhere');
        // Explicitly set white background while editing
        inp.style.backgroundColor = '#ffffff';
        inp.style.color = '#6b7280';
      }
      forceColors(); // Keep tile colors correct while typing
      // move to next editable tile
      const next = getNextEditable(idx);
      if (inp.textContent && next !== null) boardInputs[next].focus();
    });

    inp.addEventListener('keydown', (e) => {
      // If a letter key is pressed and there's already content, clear it first
      if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {
        if (inp.textContent.trim()) {
          inp.textContent = '';
        }
      }
      
      // Handle backspace - manually clear content for contenteditable divs
      if (e.key === 'Backspace') {
        e.preventDefault();
        if (inp.textContent) {
          // Text exists - delete it
          inp.textContent = '';
          inp.dispatchEvent(new Event('input', { bubbles: true }));
        } else {
          // No text - go to previous tile
          const prev = getPrevEditable(idx);
          if (prev !== null) boardInputs[prev].focus();
        }
      }
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        const prev = getPrevEditable(idx);
        if (prev !== null) boardInputs[prev].focus();
      }
      if (e.key === 'ArrowRight') {
        e.preventDefault();
        const next = getNextEditable(idx);
        if (next !== null) boardInputs[next].focus();
      }
      // Up arrow: move to same column in row above, skipping disabled tiles
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        const col = idx % 4;
        const row = Math.floor(idx / 4);
        if (row > 0) {
          let targetRow = row - 1;
          let targetIdx = targetRow * 4 + col;
          while (targetRow >= 0 && boardInputs[targetIdx].contentEditable === 'false') {
            targetRow--;
            targetIdx = targetRow * 4 + col;
          }
          if (targetRow >= 0 && targetIdx >= 0 && targetIdx < boardInputs.length) {
            boardInputs[targetIdx].focus();
          }
        }
      }
      // Down arrow: move to same column in row below, skipping disabled tiles
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        const col = idx % 4;
        const row = Math.floor(idx / 4);
        if (row < 3) {
          let targetRow = row + 1;
          let targetIdx = targetRow * 4 + col;
          while (targetRow <= 3 && boardInputs[targetIdx].contentEditable === 'false') {
            targetRow++;
            targetIdx = targetRow * 4 + col;
          }
          if (targetRow <= 3 && targetIdx < boardInputs.length) {
            boardInputs[targetIdx].focus();
          }
        }
      }
      // Submit on Enter
      if (e.key === 'Enter') {
        e.preventDefault();
        submitGuess();
      }
    });
  });

  if (keyboard) {
    keyboard.addEventListener('mousedown', (e) => {
      e.preventDefault();
      const btn = e.target.closest('.key');
      if (!btn) return;
      const key = btn.dataset.key;
      if (!key) return;
      const current = getCurrentInput();
      if (!current) return;
      const idx = boardInputs.indexOf(current);

      if (key === 'ENTER') {
        submitGuess();
        return;
      }
      if (key === 'DEL') {
        if (current.textContent) {
          current.textContent = '';
          current.dispatchEvent(new Event('input', { bubbles: true }));
        } else {
          const prev = getPrevEditable(idx);
          if (prev !== null) boardInputs[prev].focus();
        }
        return;
      }

      current.textContent = key;
      current.dispatchEvent(new Event('input', { bubbles: true }));
    });
  }

  form.addEventListener('submit', (e) => {
    for (let r = 0; r < 4; r++) {
      let txt = '';
      for (let c = 0; c < 4; c++) {
        const idx = r*4 + c;
        txt += (boardInputs[idx].textContent || ' ');
      }
      // Keep spaces as-is, only lowercase letters (don't remove spaces)
      document.getElementById(`row${r}-hidden`).value = txt.toLowerCase();
    }
    // allow form to submit normally
  });

  updateKeyboardFromBoard();
  forceColors();

  if (timer) {
    const timerValue = document.getElementById('timer-value');
    const start = parseFloat(timer.dataset.start);
    const end = parseFloat(timer.dataset.end);

    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    };

    if (!isNaN(start)) {
      const update = () => {
        const now = isNaN(end) ? (Date.now() / 1000) : end;
        const elapsed = Math.max(0, now - start);
        timerValue.textContent = formatTime(elapsed);
      };

      update();
      if (isNaN(end)) {
        setInterval(update, 500);
      }
    }
  }

  if (celebrationCanvas) {
    const ctx = celebrationCanvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const colors = ['#6aaa64', '#c9b458', '#b366cc', '#111827', '#3b82f6'];
    let particles = [];
    let startTime = performance.now();

    const resize = () => {
      celebrationCanvas.width = Math.floor(window.innerWidth * dpr);
      celebrationCanvas.height = Math.floor(window.innerHeight * dpr);
      celebrationCanvas.style.width = `${window.innerWidth}px`;
      celebrationCanvas.style.height = `${window.innerHeight}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };

    const spawnBurst = (x, y) => {
      const count = 40;
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 3;
        particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0,
          maxLife: 60 + Math.random() * 30,
          color: colors[Math.floor(Math.random() * colors.length)],
          size: 2 + Math.random() * 2
        });
      }
    };

    const tick = () => {
      const now = performance.now();
      const elapsed = now - startTime;
      ctx.clearRect(0, 0, celebrationCanvas.width, celebrationCanvas.height);
      if (elapsed < 2200 && Math.random() < 0.12) {
        const x = 60 + Math.random() * (window.innerWidth - 120);
        const y = 80 + Math.random() * (window.innerHeight * 0.4);
        spawnBurst(x, y);
      }

      particles = particles.filter(p => p.life < p.maxLife);
      for (const p of particles) {
        p.life += 1;
        p.vy += 0.04;
        p.x += p.vx;
        p.y += p.vy;
        const alpha = 1 - p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      if (elapsed < 2600 || particles.length > 0) {
        requestAnimationFrame(tick);
      } else {
        celebrationCanvas.style.display = 'none';
      }
    };

    resize();
    window.addEventListener('resize', resize);
    spawnBurst(window.innerWidth / 2, window.innerHeight / 3);
    requestAnimationFrame(tick);
  }
});
</script>

<h3>Attempts</h3>
{% if attempts %}
  <div class="attempts">
  {% for _guess in attempts %}
    {% set aidx = loop.index0 %}
    <div class="attempt-grid">
      {% for r in range(4) %}
        <div class="attempt-row">
          {% set guess_row = attempts[aidx][r] %}
          {% set fb_row = feedbacks[aidx][r] %}
          {% for c in range(4) %}
            {% set letter = guess_row[c].upper() if guess_row|length > c else '' %}
            {% set fb = fb_row[c] if fb_row|length > c else '_' %}
            {% set cls = 'absent' %}
            {% if (r, c) in revealed %}
              {% set cls = 'revealed' %}
            {% elif fb == 'G' %}
              {% set cls = 'correct' %}
            {% elif fb == 'Y' %}
              {% set cls = 'present' %}
            {% elif fb == 'P' %}
              {% set cls = 'elsewhere' %}
            {% endif %}
            <div class="attempt-tile {{ cls }}">{{ letter }}</div>
          {% endfor %}
        </div>
      {% endfor %}
    </div>
  {% endfor %}
  </div>
{% else %}
  <p>No attempts yet.</p>
{% endif %}

<script>
// Show welcome modal on first visit
function closeWelcome() {
  document.getElementById('welcome-modal').style.display = 'none';
  localStorage.setItem('wordcube-seen-welcome', 'true');
}

// Toggle welcome modal
function toggleWelcome() {
  const modal = document.getElementById('welcome-modal');
  modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
}

// Close modal when clicking overlay (outside modal)
document.getElementById('welcome-modal').addEventListener('click', (e) => {
  if (e.target.id === 'welcome-modal') {
    closeWelcome();
  }
});

// Check if user has seen the welcome modal
if (!localStorage.getItem('wordcube-seen-welcome')) {
  document.getElementById('welcome-modal').style.display = 'flex';
}

function shareResult() {
  // Get attempts and feedbacks from page data
  const gameHistory = {
    attempts: {{ attempts | tojson }},
    feedbacks: {{ feedbacks | tojson }},
    revealed: {{ revealed | tojson }},
    start_time: {{ start_time }},
    end_time: {{ end_time }}
  };

  // Convert revealed array to Set for O(1) lookup
  const revealedSet = new Set(gameHistory.revealed.map(([r, c]) => `${r},${c}`));

  // Create emoji grid
  let emojiGrid = '';
  for (let a = 0; a < gameHistory.attempts.length; a++) {
    const fb = gameHistory.feedbacks[a];
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        // Check if this tile is a revealed (given) tile
        if (revealedSet.has(`${r},${c}`)) {
          emojiGrid += 'â¬›';
        } else {
          const fbChar = fb[r][c];
          if (fbChar === 'G') {
            emojiGrid += 'ðŸŸ©';
          } else if (fbChar === 'Y') {
            emojiGrid += 'ðŸŸ¨';
          } else if (fbChar === 'P') {
            emojiGrid += 'ðŸŸª';
          } else {
            emojiGrid += 'â¬œ';
          }
        }
      }
      emojiGrid += '\n';
    }
    emojiGrid += '\n'; // Add extra newline between attempts
  }

  // Calculate time
  let endTime = gameHistory.end_time;
  if (!endTime || endTime === null) {
    endTime = Date.now() / 1000; // Use current time if end_time not set
  }
  const timeSeconds = (endTime - gameHistory.start_time);
  const mins = Math.floor(timeSeconds / 60);
  const secs = Math.floor(timeSeconds % 60);
  const timeStr = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;

  // Format attempts count
  const attemptsCount = gameHistory.attempts.length;

  // Create share text
  const gameMode = '{{ game_mode }}';
  let title = gameMode === 'daily' ? 'Daily Cube' : 'Custom Game';
  const shareText = `Word Cube ${title}\n\n${emojiGrid}\nAttempts: ${attemptsCount}\nTime: ${timeStr}\n\nPlay at: wordcubegame.com`;

  // Copy to clipboard
  navigator.clipboard.writeText(shareText).then(() => {
    // Show feedback
    const btn = document.getElementById('share-btn');
    const originalText = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(() => {
      btn.textContent = originalText;
    }, 2000);
  }).catch(err => {
    console.error('Failed to copy:', err);
    alert('Failed to copy to clipboard');
  });
}
</script>

{% endblock %}
