{% extends "base.html" %}
{% block content %}

<!-- Welcome Modal -->
<div id="welcome-modal" class="modal-overlay" style="display: none;">
  <div class="modal">
    <h2>How to Play</h2>
    <p>Fill in the 4x4 grid with words. Some letters are revealed to help you start.</p>
    <p><strong>Feedback colors:</strong></p>
    <p><span class="example-tile correct">G</span> <strong>Green:</strong> Correct letter in the right position</p>
    <p><span class="example-tile present">Y</span> <strong>Yellow:</strong> Letter exists in the same row or column, but wrong position</p>
    <p><span class="example-tile elsewhere">P</span> <strong>Purple:</strong> Letter exists elsewhere on the grid (not in same row/column)</p>
    <p>Good luck!</p>
    <button onclick="closeWelcome()">Start Playing</button>
  </div>
</div>

<div class="game-meta">
  <div class="game-links">
    <a href="{{ url_for('new_game') }}">Play Random Cube</a>
    <span class="sep">|</span>
    <a href="{{ url_for('daily_game') }}">Return to Daily</a>
    <span class="sep">|</span>
    <a href="{{ url_for('reveal_answer') }}">Reveal Answer</a>
  </div>
</div>

<h3 class="board-title">
  {% if game_mode == 'daily' %}
    Daily Cube{% if daily_date_display %} • {{ daily_date_display }}{% endif %}
  {% else %}
    Custom Game
  {% endif %}
</h3>
{# Compute last attempt/feedback if present #}
{% set last_attempt = attempts[-1] if attempts else None %}
{% set last_feedback = feedbacks[-1] if feedbacks else None %}

<div id="board" class="cube-grid {% if shake %}shake{% endif %}">
  {% for r in range(4) %}
    <div class="cube-row">
      {% for c in range(4) %}
        {% set ch = cube[r][c].upper() %}
        {% if (r, c) in revealed %}
          <input class="board-input revealed" value="{{ ch }}" disabled>
        {% else %}
          {# If there was a last attempt, use its letter and feedback for this cell #}
          {% if last_attempt and last_feedback %}
            {% set guessed_row = last_attempt[r] %}
            {% set fb_row = last_feedback[r] %}
            {% set letter = guessed_row[c].upper() if guessed_row|length > c else '' %}
            {% set fbchar = fb_row[c] if fb_row|length > c else '_' %}
            {% if fbchar == 'G' %}
              <input class="board-input correct" value="{{ letter }}" disabled data-fb="G">
            {% elif fbchar == 'Y' %}
              <input class="board-input present" maxlength="1" value="{{ letter }}" data-fb="Y">
            {% elif fbchar == 'P' %}
              <input class="board-input elsewhere" maxlength="1" value="{{ letter }}" data-fb="P">
            {% else %}
              {# show the previous guessed letter in black so it's visible on next guess #}
              <input class="board-input absent" maxlength="1" value="{{ letter }}" data-fb="_">
            {% endif %}
          {% else %}
            <input class="board-input" maxlength="1" value="" data-fb="_">
          {% endif %}
        {% endif %}
      {% endfor %}
    </div>
  {% endfor %}
</div>

{% if solved %}
  <p class="success">Solved! Well done.</p>
{% endif %}

<div class="timer" id="timer" data-start="{{ start_time|default('', true) }}" data-end="{{ end_time|default('', true) }}">
  Time: <span id="timer-value">00:00</span>
</div>

{% if solved %}
  <canvas id="celebration-canvas" aria-hidden="true"></canvas>
{% endif %}

{% if guessed_letters %}
  <div class="guessed-letters">
    <h4>Guessed Letters (Not on Board)</h4>
    <div class="guessed-list">
      {% for letter in guessed_letters|sort %}
        <div class="guessed-letter">{{ letter.upper() }}</div>
      {% endfor %}
    </div>
  </div>
{% endif %}

<form id="guess-form" method="post" action="{{ url_for('guess') }}">
  <!-- hidden row fields populated by JS from board inputs -->
  {% for i in range(4) %}
    <input type="hidden" name="row{{ i }}" id="row{{ i }}-hidden">
  {% endfor %}
  <div class="guess-submit">
    <button type="submit" class="guess-button">Submit</button>
  </div>
</form>

<script>
document.addEventListener('DOMContentLoaded', function(){
  const form = document.getElementById('guess-form');
  const boardInputs = Array.from(document.querySelectorAll('.board-input'));
  const board = document.getElementById('board');
  const celebrationCanvas = document.getElementById('celebration-canvas');
  const timer = document.getElementById('timer');

  // focus first editable tile
  const firstEditable = boardInputs.find(i => !i.disabled);
  if (firstEditable) firstEditable.focus();

  // remove shake class after animation
  if (board && board.classList.contains('shake')) {
    board.addEventListener('animationend', () => board.classList.remove('shake'));
  }

  boardInputs.forEach((inp, idx) => {
    if (inp.disabled) return;

    // initialize class based on data-fb
    const fb = inp.dataset.fb || '_';
    if (fb === 'G') { inp.classList.add('correct'); }
    else if (fb === 'Y') { inp.classList.add('present'); }
    else if (fb === 'P') { inp.classList.add('elsewhere'); }
    else { inp.classList.add('absent'); }

    // Position cursor after existing letter when focused
    inp.addEventListener('focus', () => {
      if (inp.value) {
        // Use setTimeout to ensure this happens after browser's default focus behavior
        setTimeout(() => {
          inp.setSelectionRange(inp.value.length, inp.value.length);
        }, 0);
      }
    });

    // Handle mouse clicks specifically - browser places cursor where clicked
    inp.addEventListener('click', () => {
      if (inp.value) {
        setTimeout(() => {
          inp.setSelectionRange(inp.value.length, inp.value.length);
        }, 0);
      }
    });

    inp.addEventListener('input', () => {
      inp.value = inp.value.toUpperCase().replace(/[^A-Z]/g, '');
      // if cleared, make white/black absent state so user can see empty white box
      if (!inp.value) {
        inp.classList.remove('present');
        inp.classList.remove('elsewhere');
        inp.classList.add('absent');
      } else {
        // user typed something — remove previous feedback coloring
        inp.classList.remove('absent');
        inp.classList.remove('present');
        inp.classList.remove('elsewhere');
      }
      // move to next editable tile
      let j = idx + 1;
      while (j < boardInputs.length && boardInputs[j].disabled) j++;
      if (inp.value && j < boardInputs.length) boardInputs[j].focus();
    });

    inp.addEventListener('keydown', (e) => {
      // Allow backspace to delete normally when text is selected
      if (e.key === 'Backspace') {
        if (inp.value) {
          // Text exists - allow default backspace behavior (delete)
          return;
        } else {
          // No text - go to previous tile
          let j = idx - 1;
          while (j >= 0 && boardInputs[j].disabled) j--;
          if (j >= 0) boardInputs[j].focus();
        }
      }
      if (e.key === 'ArrowLeft') {
        let j = idx - 1;
        while (j >= 0 && boardInputs[j].disabled) j--;
        if (j >= 0) boardInputs[j].focus();
      }
      if (e.key === 'ArrowRight') {
        let j = idx + 1;
        while (j < boardInputs.length && boardInputs[j].disabled) j++;
        if (j < boardInputs.length) boardInputs[j].focus();
      }
      // Up arrow: move to same column in row above, skipping disabled tiles
      if (e.key === 'ArrowUp') {
        const col = idx % 4;
        const row = Math.floor(idx / 4);
        if (row > 0) {
          let targetRow = row - 1;
          let targetIdx = targetRow * 4 + col;
          while (targetRow >= 0 && boardInputs[targetIdx].disabled) {
            targetRow--;
            targetIdx = targetRow * 4 + col;
          }
          if (targetRow >= 0 && targetIdx >= 0 && targetIdx < boardInputs.length) {
            boardInputs[targetIdx].focus();
          }
        }
      }
      // Down arrow: move to same column in row below, skipping disabled tiles
      if (e.key === 'ArrowDown') {
        const col = idx % 4;
        const row = Math.floor(idx / 4);
        if (row < 3) {
          let targetRow = row + 1;
          let targetIdx = targetRow * 4 + col;
          while (targetRow <= 3 && boardInputs[targetIdx].disabled) {
            targetRow++;
            targetIdx = targetRow * 4 + col;
          }
          if (targetRow <= 3 && targetIdx < boardInputs.length) {
            boardInputs[targetIdx].focus();
          }
        }
      }
      // Submit on Enter
      if (e.key === 'Enter') {
        e.preventDefault();
        // Populate hidden inputs and submit
        for (let r = 0; r < 4; r++) {
          let txt = '';
          for (let c = 0; c < 4; c++) {
            const idx = r*4 + c;
            txt += (boardInputs[idx].value || ' ');
          }
          document.getElementById(`row${r}-hidden`).value = txt.toLowerCase();
        }
        form.submit();
      }
    });
  });

  form.addEventListener('submit', (e) => {
    for (let r = 0; r < 4; r++) {
      let txt = '';
      for (let c = 0; c < 4; c++) {
        const idx = r*4 + c;
        txt += (boardInputs[idx].value || ' ');
      }
      // Keep spaces as-is, only lowercase letters (don't remove spaces)
      document.getElementById(`row${r}-hidden`).value = txt.toLowerCase();
    }
    // allow form to submit normally
  });

  if (timer) {
    const timerValue = document.getElementById('timer-value');
    const start = parseFloat(timer.dataset.start);
    const end = parseFloat(timer.dataset.end);

    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    };

    if (!isNaN(start)) {
      const update = () => {
        const now = isNaN(end) ? (Date.now() / 1000) : end;
        const elapsed = Math.max(0, now - start);
        timerValue.textContent = formatTime(elapsed);
      };

      update();
      if (isNaN(end)) {
        setInterval(update, 500);
      }
    }
  }

  if (celebrationCanvas) {
    const ctx = celebrationCanvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const colors = ['#6aaa64', '#c9b458', '#b366cc', '#111827', '#3b82f6'];
    let particles = [];
    let startTime = performance.now();

    const resize = () => {
      celebrationCanvas.width = Math.floor(window.innerWidth * dpr);
      celebrationCanvas.height = Math.floor(window.innerHeight * dpr);
      celebrationCanvas.style.width = `${window.innerWidth}px`;
      celebrationCanvas.style.height = `${window.innerHeight}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };

    const spawnBurst = (x, y) => {
      const count = 40;
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 3;
        particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0,
          maxLife: 60 + Math.random() * 30,
          color: colors[Math.floor(Math.random() * colors.length)],
          size: 2 + Math.random() * 2
        });
      }
    };

    const tick = () => {
      const now = performance.now();
      const elapsed = now - startTime;
      ctx.clearRect(0, 0, celebrationCanvas.width, celebrationCanvas.height);
      if (elapsed < 2200 && Math.random() < 0.12) {
        const x = 60 + Math.random() * (window.innerWidth - 120);
        const y = 80 + Math.random() * (window.innerHeight * 0.4);
        spawnBurst(x, y);
      }

      particles = particles.filter(p => p.life < p.maxLife);
      for (const p of particles) {
        p.life += 1;
        p.vy += 0.04;
        p.x += p.vx;
        p.y += p.vy;
        const alpha = 1 - p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      if (elapsed < 2600 || particles.length > 0) {
        requestAnimationFrame(tick);
      } else {
        celebrationCanvas.style.display = 'none';
      }
    };

    resize();
    window.addEventListener('resize', resize);
    spawnBurst(window.innerWidth / 2, window.innerHeight / 3);
    requestAnimationFrame(tick);
  }
});
</script>

<h3>Attempts</h3>
{% if attempts %}
  <div class="attempts">
  {% for _guess in attempts %}
    {% set aidx = loop.index0 %}
    <div class="attempt-grid">
      {% for r in range(4) %}
        <div class="attempt-row">
          {% set guess_row = attempts[aidx][r] %}
          {% set fb_row = feedbacks[aidx][r] %}
          {% for c in range(4) %}
            {% set letter = guess_row[c].upper() if guess_row|length > c else '' %}
            {% set fb = fb_row[c] if fb_row|length > c else '_' %}
            {% set cls = 'absent' %}
            {% if (r, c) in revealed %}
              {% set cls = 'revealed' %}
            {% elif fb == 'G' %}
              {% set cls = 'correct' %}
            {% elif fb == 'Y' %}
              {% set cls = 'present' %}
            {% elif fb == 'P' %}
              {% set cls = 'elsewhere' %}
            {% endif %}
            <div class="attempt-tile {{ cls }}">{{ letter }}</div>
          {% endfor %}
        </div>
      {% endfor %}
    </div>
  {% endfor %}
  </div>
{% else %}
  <p>No attempts yet.</p>
{% endif %}

<script>
// Show welcome modal on first visit
function closeWelcome() {
  document.getElementById('welcome-modal').style.display = 'none';
  localStorage.setItem('wordcube-seen-welcome', 'true');
}

// Check if user has seen the welcome modal
if (!localStorage.getItem('wordcube-seen-welcome')) {
  document.getElementById('welcome-modal').style.display = 'flex';
}
</script>

{% endblock %}
